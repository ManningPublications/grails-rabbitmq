<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2 Configuration</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="2 Configuration">2 Configuration</a></h1>The plugin supports a number of configuration options which all may be expressed in <code>grails-app/conf/Config.groovy</code>.  A
basic configuration might look something like this:<p class="paragraph"/><div class="code"><pre>// grails&#45;app/conf/Config.groovy
rabbitmq &#123;
    connectionfactory &#123;
        username = 'guest'
        password = 'guest'
        hostname = 'localhost'
    &#125;
&#125;</pre></div><p class="paragraph"/>Those are settings which are necessary in order for the plugin to be able to connect to and communicate with a
RabbitMQ server.<p class="paragraph"/>Following is a list of other configuration settings supported by the plugin.<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Configuration Property</strong></th><th><strong class="bold">Description</strong></th><th><strong class="bold">Default</strong></th></tr><tr class="table-odd"><td>rabbitmq.connectionfactory.username</td><td>The user name for connection to the server</td><td>(none)</td></tr><tr class="table-even"><td>rabbitmq.connectionfactory.password</td><td>The password for connection to the server</td><td>(none)</td></tr><tr class="table-odd"><td>rabbitmq.connectionfactory.hostname</td><td>The host name of the server</td><td>(none)</td></tr><tr class="table-even"><td>rabbitmq.connectionfactory.channelCacheSize</td><td>The connection channel cache size</td><td>10</td></tr><tr class="table-odd"><td>rabbitmq.concurrentConsumers</td><td>The number of concurrent consumers to create per message handler.  Raising the number is recommendable in order to scale the consumption of messages coming in from a queue.  Note that ordering guarantees are lost when multiple consumers are registered.</td><td>1</td></tr></table><h2><a name="2.1 Configuring Queues">2.1 Configuring Queues</a></h2>If the Grails application will be sending messages to or receiving messages from Queues that may not already be declared
in the RabbitMQ server, the application needs to declare those Queues up front.  One way to do that is to add beans
to the Spring Application Context of type <code>org.springframework.amqp.core.Queue</code>.  That might look something like this:<p class="paragraph"/><div class="code"><pre>// grails&#45;app/conf/spring/resources.groovy
beans = &#123;
    myQueue(org.springframework.amqp.core.Queue, 'myQueueName') 
    myOtherQueue(org.springframework.amqp.core.Queue, 'myOtherQueueName') &#123;
        autoDelete = <span class="java&#45;keyword">false</span>
        durable = <span class="java&#45;keyword">true</span>
        exclusive = <span class="java&#45;keyword">false</span>
        arguments = &#91;arg1: 'val1', arg2: 'val2'&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>The plugin also supports a DSL for describing these Queues.  This DSL is expressed in
<code>grails-app/conf/Config.groovy</code>.  The code below shows how to describe same Queues that
were described in the previous code sample.<p class="paragraph"/><div class="code"><pre></pre></div>
// grails-app/conf/Config.groovy
rabbitmq {
    connectionfactory {
        username = 'guest'
        password = 'guest'
        hostname = 'localhost'
    }
    queues = {
        myQueueName()
        myOtherQueueName autoDelete: false, durable: true, exclusive: false, arguments: arg1: 'val1', arg2: 'val2'
    }
}
<div class="code"><pre></pre></div>
    </body>
</html>
