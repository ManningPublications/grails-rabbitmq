<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2. Configuration</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="2. Configuration">2. Configuration</a></h1>The plugin supports a number of configuration options which all may be expressed in <code>grails-app/conf/Config.groovy</code>. A basic configuration might look something like this:<p class="paragraph"/><div class="code"><pre>// grails&#45;app/conf/Config.groovy
rabbitmq &#123;
    connectionfactory &#123;
        username = 'guest'
        password = 'guest'
        hostname = 'localhost'
    &#125;
&#125;</pre></div><p class="paragraph"/>Those are settings which are necessary in order for the plugin to be able to connect to and communicate with a RabbitMQ server.<p class="paragraph"/>Following is a list of other configuration settings supported by the plugin.<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Configuration Property</strong></th><th><strong class="bold">Description</strong></th><th><strong class="bold">Default</strong></th></tr><tr class="table-odd"><td>rabbitmq.connectionfactory.username</td><td>The user name for connection to the server</td><td>(none)</td></tr><tr class="table-even"><td>rabbitmq.connectionfactory.password</td><td>The password for connection to the server</td><td>(none)</td></tr><tr class="table-odd"><td>rabbitmq.connectionfactory.hostname</td><td>The host name of the server</td><td>(none)</td></tr><tr class="table-even"><td>rabbitmq.connectionfactory.virtualHost</td><td>The name of the virtual host to connect to</td><td>'/'</td></tr><tr class="table-odd"><td>rabbitmq.connectionfactory.channelCacheSize</td><td>The connection channel cache size</td><td>10</td></tr><tr class="table-even"><td>rabbitmq.concurrentConsumers</td><td>The number of concurrent consumers to create per message handler.  Raising the number is recommendable in order to scale the consumption of messages coming in from a queue.  Note that ordering guarantees are lost when multiple consumers are registered.</td><td>1</td></tr></table>
<h2><a name="2.1 Configuring Queues">2.1 Configuring Queues</a></h2>Queues must be declared in the RabbitMQ server before consumers can be associated with those queues and before messages may be sent to those queues. If the Grails application will be sending messages to or receiving messages from queues that may not already be declared in the RabbitMQ server, the application needs to declare those queues up front. One way to do that is to add beans to the Spring application context of type <code>org.springframework.amqp.core.Queue</code>. That 
might look something like this:<p class="paragraph"/><div class="code"><pre>// grails&#45;app/conf/spring/resources.groovy
beans = &#123;
    myQueue(org.springframework.amqp.core.Queue, 'myQueueName') 
    myOtherQueue(org.springframework.amqp.core.Queue, 'myOtherQueueName') &#123;
        autoDelete = <span class="java&#45;keyword">false</span>
        durable = <span class="java&#45;keyword">true</span>
        exclusive = <span class="java&#45;keyword">false</span>
        arguments = &#91;arg1: 'val1', arg2: 'val2'&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>The plugin also supports a DSL for describing these queues. This DSL is expressed in <code>grails-app/conf/Config.groovy</code>. The code below configures the same queues as the previous code sample.<p class="paragraph"/><div class="code"><pre>// grails&#45;app/conf/Config.groovy
rabbitmq &#123;
    connectionfactory &#123;
        username = 'guest'
        password = 'guest'
        hostname = 'localhost'
    &#125;
    queues = &#123;
        myQueueName()
        myOtherQueueName autoDelete: <span class="java&#45;keyword">false</span>, durable: <span class="java&#45;keyword">true</span>, exclusive: <span class="java&#45;keyword">false</span>, arguments: &#91;arg1: 'val1', arg2: 'val2'&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
With both techniques, the <code>autoDelete</code>, <code>durable</code> and <code>exclusive</code> attributes default to <code>false</code> and the <code>arguments</code> attribute defaults to null.
</blockquote><p class="paragraph"/>So what do those queue options mean?<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Option</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>autoDelete</td><td>If <code>true</code>, the queue will be removed from the broker when there are no more clients attached to it. Note that this doesn't take effect until after at least one client connects to the queue.</td></tr><tr class="table-even"><td>durable</td><td>If <code>true</code>, the queue will survive a restart of the broker.</td></tr><tr class="table-odd"><td>exclusive</td><td>Only the client that created the queue can connect to it.</td></tr></table><p class="paragraph"/>One final thing: when you declare a standalone queue like this, it automatically gets bound to the broker's default exchange, which has an implicit name of '', i.e. the empty string. You can easily send messages to this queue via the <a href="../ref/All Classes/rabbitSend.html" class="allClasses">rabbitSend</a> method.
<h2><a name="2.2 Configuring Exchanges">2.2 Configuring Exchanges</a></h2>Queues are the foundation of consuming messages, but what if you want to send messages? In AMQP, you send messages to an exchange and the exchange then routes those messages to the appropriate queues based on something called a binding. The key to setting up complex messaging systems lies in configuring these exchanges and queues appropriately.<p class="paragraph"/><h3>Declaring an exchange</h3><p class="paragraph"/>Let's start with an example of how to set up a simple exchange (with no queues):<p class="paragraph"/><div class="code"><pre>rabbitmq &#123;
    connectionFactory &#123;
        &#8230;
    &#125;
    queues = &#123;
        exchange name: 'my.topic', type: topic
    &#125;
&#125;</pre></div><p class="paragraph"/>As you can probably guess, this will create a topic exchange with the name 'my.topic'. There are two things to note at this point:
<ol>
<li>the name and type are required</li>
<li>the type value is  <em class="italic">not</em>  a string literal</li>
</ol><p class="paragraph"/>So what types are available to you?<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Type</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>direct</td><td>An exchange that only routes messages that are bound to it with a key that matches the routing key of the message exactly. Typically this exchange is used for point-to-point messaging and the routing key is the queue name.</td></tr><tr class="table-even"><td>fanout</td><td>Sends messages to all queues bound to it. It basically does a broadcast.</td></tr><tr class="table-odd"><td>topic</td><td>Similar to the <code>fanout</code> exchange, this routes messages to the queues bound to it, but only queues whose binding matches a message's routing key will receive that message. Wildcards are supported in the binding.</td></tr><tr class="table-even"><td>headers</td><td>Similar to topic, but messages can be filtered by other any message header, not just the routing key.</td></tr></table><p class="paragraph"/>The exchange declaration also supports a couple of extra options that should be familiar from the queue declarations:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Option</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>autoDelete</td><td>If <code>true</code>, the exchange will be removed from the broker when there are no more queues bound to it. Note that this doesn't take effect until at least one queue is bound to the exchange.</td></tr><tr class="table-even"><td>durable</td><td>If <code>true</code>, the exchange will survive a restart of the broker.</td></tr></table><p class="paragraph"/>With the above syntax, it is up to you to bind queues to the exchange via another AMQP client or via the RabbitMQ management interface. In other words, this is most suitable if your Grails application is purely a publisher of messages and not a consumer (or at least not a consumer of 'my.topic' messages).<p class="paragraph"/>What if you want to create queues and automatically bind them to the exchange? Don't worry, that's supported by the configuration DSL too.<p class="paragraph"/><h3>Binding queues to exchanges</h3><p class="paragraph"/>An exchange on its own isn't particularly useful, but we can easily bind queues to it by declaring them as nested entries:<p class="paragraph"/><div class="code"><pre>rabbitmq &#123;
    connectionFactory &#123;
        &#8230;
    &#125;
    queues = &#123;
        exchange name: 'my.topic', type: topic, durable: <span class="java&#45;keyword">false</span>, &#123;
            foo durable: <span class="java&#45;keyword">true</span>, binding: 'shares.&#35;'
            bar durable: <span class="java&#45;keyword">false</span>, autoDelete: <span class="java&#45;keyword">true</span>, binding: 'shares.nyse.?'
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>In the example above, we bind two queues ('foo' and 'bar') to the exchange 'my.topic'. Since this is a topic exchange, we can use a binding key to filter which messages go from 'my.topic' to each queue. So in this case, only messages with a routing key beginning with 'shares.' will end up on the 'foo' queue. 'bar' will only receive messages whose routing key begins with 'shares.nyse.'.<p class="paragraph"/>This approach isn't limited to topic exchanges: you can automatically bind queues to any exchange type. There are a few things to bear in mind though:
<ol>
<li>the default binding for direct exchanges is the queue name (unless this is explicitly overridden by a 'binding' option);</li>
<li>the 'binding' is ignored for fanout exchanges; and</li>
<li>the headers exchange requires a map of message header names and values for its binding.</li>
</ol><p class="paragraph"/>As you can imagine, these few building blocks allow you to configure some pretty complex messaging systems with very little effort. You can tailor the messaging system to your needs rather than tailor your applications to the messaging system.<p class="paragraph"/>

    </body>
</html>
