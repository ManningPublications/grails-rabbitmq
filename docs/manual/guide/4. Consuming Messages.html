<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>4. Consuming Messages</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="4. Consuming Messages">4. Consuming Messages</a></h1>The plugin provides two simple ways of consuming messages:
<ol>
<li>from a named Queue</li>
<li>by subscribing to an exchange (the traditional pub/sub model)</li>
</ol><p class="paragraph"/>Which approach you take depends on whether you want to implement the pub/sub messaging model and how much control you need.
<h2><a name="4.1 Pub-Sub">4.1 Pub-Sub</a></h2>One of the most common messaging models people use involves a producer broadcasting messages to all registered listeners (or more accurately, consumers). This is known as the publish/subscribe model, or pub/sub for short. There are two steps to getting this set up in Grails:
<ol>
<li>create the exchange you're going to publish messages to</li>
<li>create some consumers that subscribe to that exchange</li>
</ol><p class="paragraph"/>The first step can be done either outside of the Grails application or in the plugin's configuration. If the Grails application is the publisher, then it makes sense to declare the exchange in <code>grails-app/conf/Config.groovy</code>.<p class="paragraph"/>The second step is dead easy with the plugin: create a service with a static <code>rabbitSubscribe</code> property and a <code>handleMessage()</code> method. Here's an example:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.example<p class="paragraph"/>class SharesService &#123;
    <span class="java&#45;keyword">static</span> rabbitSubscribe = 'shares'<p class="paragraph"/>    void handleMessage(message) &#123;
        // handle message&#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>As long as the broker contains an exchange with the name <code>shares</code>, the <code>SharesService</code> will receive all messages sent to that exchange. Every time a message is received from the broker, the service's <code>handleMessage()</code> method is called with the message as its argument. We'll talk more about messages shortly.<p class="paragraph"/><blockquote class="note">
The <code>rabbitSubscribe</code> option only makes sense when applied to fanout and topic exchanges.
</blockquote><p class="paragraph"/>In the case of a topic exchange, you can filter messages based on the routing key. By default your service will receive all messages, but you can override this with an alternative syntax for <code>rabbitSubscribe</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.example<p class="paragraph"/>class SharesService &#123;
    <span class="java&#45;keyword">static</span> rabbitSubscribe = &#91; name: 'shares', routingKey: 'NYSE.GE' &#93;
    &#8230;
&#125;</pre></div><p class="paragraph"/>In this example, the service will only receive messages that have a routing key of 'GE'. Of course, you can use standard AMQP wildcards too like 'NYSE.#', which will match all messages with a routing key that starts with 'NYSE.'.<p class="paragraph"/>Under the hood, the plugin creates a temporary, exclusive queue for your service which is removed from the broker when your application shuts down. There is no way for you to control the name of the queue or attach another listener to it, but then that's the point in this case. If you do need more control, then you must manage the queues and their bindings yourself.<p class="paragraph"/><h2><a name="4.2 Manual queue management">4.2 Manual queue management</a></h2>The plugin provides a convention based mechanism for associating a listener with a queue. Any Grails Service may express that it wants to receive messages on a specific queue by defining a static property named <code>rabbitQueue</code> and
assigning the property a string which represents the name of a queue.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.grails.rabbitmq.test<p class="paragraph"/>class DemoService &#123;
    <span class="java&#45;keyword">static</span> rabbitQueue = 'someQueueName'<p class="paragraph"/>    void handleMessage(message) &#123;
        // handle message&#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>As with the pub/sub model, messages are delivered to the service by invoking the <code>handleMessage()</code> method. That's all there is to it! The real trick is to configure your exchanges and queues with appropriate bindings, as we described in the configuration section.<p class="paragraph"/>One last subject to discuss is the form that the messages take.
<h2><a name="4.3 Messages">4.3 Messages</a></h2>What is a message? In the examples you've seen in this section, the message has been some arbitrary object but we haven't discussed what the type of that object might be. That's because, it can be pretty much anything! Within the messaging system, the content of a message is simply a byte array - it's up to the producer can consumer to interpret/convert that raw data.<p class="paragraph"/>Fortunately the plugin (via <a href="http://static.springsource.org/spring-amqp/docs/1.0.x/reference/htmlsingle/#d0e335" target="blank">Spring AMQP</a>) automatically handles messages whose content is in familiar forms, including:
<ul class="star">
<li>strings</li>
<li>byte arrays</li>
<li>maps</li>
<li>other serializable types</li>
</ul><p class="paragraph"/>One manifestation of this support is that different message types may be handled with overloaded versions of <code>handleMessage()</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.grails.rabbitmq.test<p class="paragraph"/>class DemoService &#123;
    <span class="java&#45;keyword">static</span> rabbitQueue = 'someQueueName'<p class="paragraph"/>    void handleMessage(<span class="java&#45;object">String</span> textMessage) &#123;
        // handle <span class="java&#45;object">String</span> message&#8230;
    &#125;<p class="paragraph"/>    void handleMessage(Map mapMessage) &#123;
        // handle Map message&#8230;
    &#125;<p class="paragraph"/>    void handleMessage(<span class="java&#45;object">byte</span>&#91;&#93; byteMessage) &#123;
        // handle <span class="java&#45;object">byte</span> array message&#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>This is a great convenience, but be aware that using serializable Java objects limits the types of client you can interact with. If all the clients you're interested in are using Spring AMQP, then you should be fine, but don't expect Ruby or Python clients to handle <code>Map</code> messages! For production systems, we recommend you use strings and byte arrays.

    </body>
</html>
