Queues must be declared in the RabbitMQ server before consumers can be associated with those Queues and before messages
may be sent to those Queues.  If the Grails application will be sending messages to or receiving messages from Queues 
that may not already be declared in the RabbitMQ server, the application needs to declare those Queues up front.  One 
way to do that is to add beans to the Spring Application Context of type @org.springframework.amqp.core.Queue@.  That 
might look something like this:

{code}
// grails-app/conf/spring/resources.groovy
beans = {
    myQueue(org.springframework.amqp.core.Queue, 'myQueueName') 
    myOtherQueue(org.springframework.amqp.core.Queue, 'myOtherQueueName') {
        autoDelete = false
        durable = true
        exclusive = false
        arguments = [arg1: 'val1', arg2: 'val2']
    }
}
{code}

The plugin also supports a DSL for describing these Queues.  This DSL is expressed in
@grails-app/conf/Config.groovy@.  The code below shows how to describe same Queues that
were described in the previous code sample.

{code}
// grails-app/conf/Config.groovy
rabbitmq {
    connectionfactory {
        username = 'guest'
        password = 'guest'
        hostname = 'localhost'
    }
    queues = {
        myQueueName()
        myOtherQueueName autoDelete: false, durable: true, exclusive: false, arguments: [arg1: 'val1', arg2: 'val2']
    }
}
{code}

With both techniques, the @autoDelete@, @durable@ and @exclusive@ attributes default to @false@ and the @arguments@ attribute defaults to null.